std::rc: module -> pub {
    ControlBlock: struct {
        value_ptr:    Ptr,
        strong_count: int,
        weak_count:   int,
    }

    impl ControlBlock {
        value_ptr(self_ptr: Ptr): Ptr {
            ret __deref_as[ControlBlock](self_ptr).value_ptr;
        }

        strong_count(self_ptr: Ptr): int {
            ret __deref_as[ControlBlock](self_ptr).strong_count;
        }

        set_strong_count(self_ptr: Ptr, value: int): void {
            __deref_as[ControlBlock](self_ptr).strong_count = value;
        }

        increment_strong_count(self_ptr: Ptr): void {
            set_strong_count(self_ptr, strong_count(self_ptr) + 1);
        }

        decrement_strong_count(self_ptr: Ptr): void {
            assert strong_count(self_ptr) > 0;
            set_strong_count(self_ptr, strong_count(self_ptr) - 1);
        }

        weak_count(self_ptr: Ptr): int {
            ret __deref_as[ControlBlock](self_ptr).weak_count;
        }

        set_weak_count(self_ptr: Ptr, value: int): void {
            __deref_as[ControlBlock](self_ptr).weak_count = value;
        }

        increment_weak_count(self_ptr: Ptr): void {
            set_weak_count(self_ptr, weak_count(self_ptr) + 1);
        }

        decrement_weak_count(self_ptr: Ptr): void {
            assert weak_count(self_ptr) > 0;
            set_weak_count(self_ptr, weak_count(self_ptr) - 1);
        }
    }

    StrongPtr[T]: struct -> pub {
        internal_data: StrongPtrInternalData[T],
    }

    StrongPtrInternalData[T]: struct {
        value_ptr:         Ptr,
        control_block_ptr: Ptr,
    }

    impl[T] StrongPtr[T] {
        value_ptr(self: &StrongPtr[T]): Ptr {
            ret __deref_as[StrongPtrInternalData[T]](self).value_ptr;
        }

        set_value_ptr(self: &StrongPtr[T], value: Ptr): void {
            __deref_as[StrongPtrInternalData[T]](self).value_ptr = value;
        }

        control_block_ptr(self: &StrongPtr[T]): Ptr {
            ret __deref_as[StrongPtrInternalData[T]](self).control_block_ptr;
        }

        set_control_block_ptr(self: &StrongPtr[T], value: Ptr): void {
            __deref_as[StrongPtrInternalData[T]](self).control_block_ptr = value;
        }

        new(value: &T): StrongPtr[T] -> pub {
            value_ptr:         Ptr = mem::alloc(__size_of[T]);
            control_block_ptr: Ptr = mem::alloc(__size_of[ControlBlock]);

            internal_data: StrongPtrInternalData[T] = new StrongPtrInternalData[T] {
                value_ptr,
                control_block_ptr,
            };

            control_block: ControlBlock = new ControlBlock {
                value_ptr,
                strong_count: 1, 
                weak_count:   0,
            };

            mem::copy(Ref[T]::ptr(value), value_ptr, __size_of[T]);
            mem::copy(
                __address_of(control_block),
                control_block_ptr,
                __size_of[ControlBlock]
            );

            ret new StrongPtr[T] { internal_data };
        }

        from(weak_ptr: &WeakPtr[T]): StrongPtr[T] {
            ControlBlock::increment_strong_count(weak_ptr.control_block_ptr);

            internal_data: StrongPtrInternalData[T] = new StrongPtrInternalData[T] {
                value_ptr: ControlBlock::value_ptr(weak_ptr.control_block_ptr),
                control_block_ptr: weak_ptr.control_block_ptr,
            };

            ret new StrongPtr[T] { internal_data };
        }

        op copy(self: &StrongPtr[T], other: &StrongPtr[T]): void -> pub {
            set_value_ptr        (self, value_ptr(other));
            set_control_block_ptr(self, control_block_ptr(other));

            ControlBlock::increment_strong_count(control_block_ptr(self));
        }

        op drop(self: &StrongPtr[T]): void -> pub {
            ControlBlock::decrement_strong_count(control_block_ptr(self));

            if ControlBlock::strong_count(control_block_ptr(self)) == 0 {
                mem::dealloc(value_ptr(self));

                if ControlBlock::weak_count(control_block_ptr(self)) == 0 {
                    mem::dealloc(control_block_ptr(self));
                }
            }
        }

        value(self: &StrongPtr[T]): T -> pub {
            ret __deref_as[T](value_ptr(self));
        }
    }

    WeakPtr[T]: struct -> pub {
        control_block_ptr: Ptr,
    }

    impl[T] WeakPtr[T] {
        from(strong_ptr: &StrongPtr[T]): WeakPtr[T] -> pub {
            control_block_ptr: Ptr =
                StrongPtr[T]::control_block_ptr(strong_ptr);
            ControlBlock::increment_weak_count(control_block_ptr);
            ret new WeakPtr[T] { control_block_ptr };
        }
 
        op copy(self: &WeakPtr[T], other: &WeakPtr[T]): void -> pub {
            self.control_block_ptr = other.control_block_ptr;

            ControlBlock::increment_weak_count(self.control_block_ptr);
        }

        op drop(self: &WeakPtr[T]): void -> pub {
            ControlBlock::decrement_weak_count(self.control_block_ptr);

            if 
                (ControlBlock::strong_count(self.control_block_ptr) == 0) && 
                (ControlBlock::weak_count(self.control_block_ptr) == 0) 
            {
                mem::dealloc(self.control_block_ptr);
            }
        }

        lock(): StrongPtr[T] -> pub self {
            assert ControlBlock::strong_count(self.control_block_ptr) > 0;
            ret StrongPtr[T]::from(self);
        }
    }
}
