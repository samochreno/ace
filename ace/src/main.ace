Vector2: struct -> pub {
    x: int -> pub, 
    y: int -> pub,
}

Template[T]: struct {
    field: T
}

impl Vector2 {
    increment_all(): void -> pub self {
        self.x += 1;
        self.y += 1;
    }

    increment_all_static(self: &Vector2): void -> pub {
        self.increment_all();
    }
}

test_1(): int {
    vec: Vector2 = new Vector2 { x: 15, y: 15 };
    vec.increment_all();

    vec_ref: &Vector2 = vec;
    vec_ref.increment_all();

    vec.increment_all();

    Vector2::increment_all_static(vec_ref);

    ret vec.y;
}

test_2: module {
    Type: struct -> pub {
        field: int
    }

    impl Type {
        new(field: int): Type -> pub {
            ret new Type { field };
        }

        field(): int -> pub self { 
            ret self.field;
        }
    }

    private: module {
        func(): int {
            obj: test_2::Type = new test_2::Type { field: 1 };
            ret obj.field;
        }
    }
}

test_3: module {
    func(): int -> pub {
        ret -5;
    }
}

test_3::nested: module -> pub {
}

test_3::nested: module -> pub {
    func(): int -> pub {
        ret -10;
    }
}

test_4(): int {
    i: int = 0; 

    while i < 10 {
        print_int(i);
        i += 1;
    }

    ret i;
}

fizz_buzz(n: int): int { # FizzBuzz -> Fizz = 8888, Buzz = 1111, FizzBuzz = 88881111.
    i: int = 1;
    while i <= n {
        is_divisable_by_three: bool = i % 3 == 0;
        is_divisable_by_five:  bool = i % 5 == 0;

        if is_divisable_by_three {
            if is_divisable_by_five {
                print_int(88881111);
            } else {
                print_int(8888);
            }
        } else {
            if is_divisable_by_five {
                print_int(1111);
            } else {
                print_int(i);
            }
        }

        i += 1;
    }

    ret 999999;
}

control_flow_analysis_1(): int {
    if false {
        ret 15;
    } else {
        ret 16;
    }
}

control_flow_analysis_2(): int {
    while true {
        ret 12;
    }

    ret 16;
}

impl[T] Template[T] {
    field(): T -> pub self {
        ret self.field;
    }
}

test_10(): int {
    obj: Template[int] = new Template[int] { field: 4 };
    ret obj.field();
}

impl[T] Template[T] {
    func_normal(): void {
        print_int(15);
    }

    func_template[U](): void {
        print_int(25);
    }
}

type_template_associated_func_template(): int {
    Template[int]::func_normal();
    Template[int]::func_template[std::Pointer]();
    ret 10;
}

free_func_template[T](value: T): T {
    ret value;
}

free_func_template_test(): int {
    ret free_func_template[int](-13);
}

impl[T] Template[T] {
    print_field[U](): void -> self {
        print_int(self.field);
    }
}

method_template(): int {
    obj: Template[int] = new Template[int] { field: -12 };
    obj.print_field[std::Pointer]();
    ret 13;
}

clamp(d: int, min: int, max: int): int {
    t: int;

    if d < min { t = min; }
    else       { t = d; }

    if t > max { ret max; }
    else       { ret t; }
}

impl Vector2 {
    associated_func_template[T](): void -> self { 
    }
}

type_associated_template_func(): int {
    vec: Vector2 = new Vector2 { x: 0, y: 0 };
    vec.associated_func_template[int]();
    ret vec.x + vec.y;
}

impl Vector2 {
    increment_x_and_y(): void -> self {
        self.x += 1;
        self.y += 1;
    }
}

reference(): int {
    vec_a: Vector2 = new Vector2 { x: 48, y: 11 };
    vec_b: Vector2 = new Vector2 { x: -9, y: 59 };

    vec_b.increment_x_and_y();

    vec_ref: &Vector2 = vec_b;

    vec_b.x += 1;

    vec_final: Vector2 = vec_ref;

    ret vec_final.x;
}

impl Vector2 {
    operator +(lhs: &Vector2, rhs: &Vector2): Vector2 -> pub {
        ret new Vector2 {
            x: lhs.x + rhs.x,
            y: lhs.y + rhs.y,
        };
    }
}

operator_reference_parameter(): int {
    vec_a: Vector2 = new Vector2 { x: 5,  y: 10 };
    vec_b: Vector2 = new Vector2 { x: 10, y: 20 };

    vec_c: Vector2 = vec_a + vec_b;

    ret vec_c.y;
}

impl[T] Template[T] {
    clone(value: Template[T]): Template[T] {
        ret new Template[T] { field: value.field };
    }
}

clone(): int {
    original: Template[int] = new Template[int] { field: 5 };
    cloned:   Template[int] = Template[int]::clone(original);
    ret cloned.field;
}

argument(value: int): int {
    ret value;
}

RAII: struct { 
}

impl RAII {
    new(): RAII {
        print_int(11111);
        ret new RAII { };
    }

    operator copy(self: &RAII, other: &RAII): void -> pub {
        print_int(22222);
    }

    operator drop(self: &RAII): void -> pub {
        print_int(33333);
    }
}

raii(): int {
    obj: RAII = RAII::new();
    print_int(500);
    ret -1;
}

TemplatedAddable[T]: struct {
    value: T
}

impl[T] TemplatedAddable[T] { 
    operator +(lhs: &TemplatedAddable[T], rhs: &TemplatedAddable[T]): TemplatedAddable[T] -> pub {
        ret new TemplatedAddable[T] {
            value: lhs.value + rhs.value 
        };
    } 
}

templated_addable(): int {
    a: TemplatedAddable[int] = new TemplatedAddable[int] { value: 5 };
    b: TemplatedAddable[int] = new TemplatedAddable[int] { value: -10 };
    c: TemplatedAddable[int] = a + b; 

    ret c.value;
}

POD: struct {
    value: int
}

impl POD {
    operator drop(self: &POD): void -> pub {
        print_int(self.value);
    }
}

print_on_drop(): int {
    i: int = 0;

    while i < 5 {
        x: POD = new POD { value: -5 };
        i += 1;
    }

    a: POD = new POD { value: 1 };
    b: POD = new POD { value: 2 };

    {
        c: POD = new POD { value: 3 };
    }

    {
        d: POD = new POD { value: 4 };

        ret 0;

        e: POD = new POD { value: 5 };
    }

    f: POD = new POD { value: 6 };

    ret 0;
}

POC: struct {
    value: int
}

impl POC {
    operator copy(self: &POC, other: &POC): void -> pub {
        self.value = other.value;
        print_int(self.value);
    }
}

argument_copy_test(value: POC): void {
}

print_on_copy(): int {
    a: POC;
    b: POC;

    a = new POC { value: 10 };
    a.value = -5;

    b = a;
    b.value = 16;

    argument_copy_test(b);

    ret -28;
}

PL: struct {
}

impl PL {
    new(): PL {
        print_int(11111);
        ret new PL { };
    }

    operator copy(self: &PL, other: &PL): void -> pub {
        print_int(22222);
    }

    operator drop(self: &PL): void -> pub {
        print_int(33333);
    }
}

print_lifetime(): int {
    pl: PL = PL::new();
    ret 0;
}

address(): int {
    value: int = 0;
    address_of_value: std::Pointer = __address_of(value);
    ret value;
}

size_of_vector_2(): int {
    ret __size_of[Vector2];
}

memory_allocation(): int {
    size_of_int: int = __size_of[int];
    block: std::Pointer = std::mem::alloc(size_of_int);
    std::mem::dealloc(block);
    ret 0;
}

memory_allocation_copy_access(): int {
    vector_2_size: int = __size_of[Vector2];
    vector_2_ptr: std::Pointer = std::mem::alloc(vector_2_size);

    init_value: Vector2 = new Vector2 { x: 15, y: 7 };
    init_value_ptr: std::Pointer = __address_of(init_value);

    std::mem::copy(init_value_ptr, vector_2_ptr, vector_2_size);

    __deref_as[Vector2](vector_2_ptr).y = 46;

    vector_2_deref_y: int = __deref_as[Vector2](vector_2_ptr).y;

    std::mem::dealloc(vector_2_ptr);

    ret vector_2_deref_y;
}

print_vector_2_strong_pointer_x(value: &*Vector2): void {
    print_int(value.x);
}

print_vector_2_strong_pointer_y(value: &*Vector2): void {
    print_int(value.y);
}

reference_counting(): int {
    strong: *Vector2 = box new Vector2 { x: 16, y: 10 };
    print_vector_2_strong_pointer_y(strong);

    weak: ~Vector2 = strong;

    locked: *Vector2 = weak.lock();
    print_vector_2_strong_pointer_x(locked);

    unboxed_value: Vector2 = unbox locked;
    print_int(unboxed_value.y);

    ret 0;
}

multiple_indirection(): int {
    vec_1: *Vector2 = box new Vector2 { x: -7, y: 4 };
    vec_2: **Vector2 = box vec_1;
    vec_3: &**Vector2 = vec_2;

    ret vec_3.x;
}

compound_assignment(): int {
    value: int = 10;
    increment_int(value);
    ret value;
}

increment_int(value: &int): void {
    value += 1;
}

compound_assignment_struct(): int {
    value: Vector2 = new Vector2 { x: 3, y: -27 };
    value.y -= 1;
    print_int(value.y);

    boxed_value: *Vector2 = box value;
    boxed_value.x *= 2;
    print_int(boxed_value.x);

    ret 0;
}

operator_precedence(): int {
    i: int = -int_value();
    print_int(i);
    ret 0;
}

int_value(): int {
    ret -15;
}

operator_associativity(): int {
    ret 1 * -100 + 50 / 10 / 5;
}

Getter: struct {
    field: int,
}

impl Getter {
    field(): int -> self {
        ret self.field;
    }
}

getter(): int {
    obj: Getter = new Getter { field: -12349 };
    ret obj.field();
}

main(): int {
    value: int = getter();
    print_int(value);
    ret value;
}

print_int(value: int): void -> pub extern;

print_ptr(ptr: std::Pointer): void -> pub extern;
