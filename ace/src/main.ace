pub extern ::
print_int(value: int): void;

pub extern ::
print_ptr(ptr: std::Ptr): void;

main(): int {
    test();
    ret 0;
}

test(): void {
    i: int = 0;

    i += compound_assignment();
    assert i == 11;

    i += struct_compound_assignment();
    assert i == 37;

    i += boxed_struct_compound_assignment();
    assert i == 41;

    i += boxed_self();
    assert i == 53;

    i += self_type();
    assert i == 55;

    i += traits();
    assert i == 57;

    i += static_trait_dispatch();
    assert i == 66;

    i += dyn_trait_dispatch();
    assert i == 70;

    i += vtbl_lookup();
    assert i == 79;

    i += constraint();
    assert i == 81;

    print_int(0);
}

Constraint: trait {
    self ::
    get(): Self;
}

impl Constraint for int {
    self ::
    get(): Self {
        ret self;
    }
}

constrained[T](value: &T): T where T: Constraint {
    ret value.get();
}

constraint(): int {
    ret constrained(2);
}

vtbl_lookup(): int {
    dyn: *Dyn = box 9;
    dyn_weak: ~Dyn = dyn;
    dyn_locked: *Dyn = lock dyn_weak;
    ret dyn_locked.value();
}

Dyn: trait {
    *self ::
    ten(): int;

    *self ::
    value(): int;

    self ::
    self_value(): int;
}

impl Dyn for int {
    *self ::
    ten(): int {
        ret 10;
    }

    *self ::
    value(): int {
        ret unbox self;
    }

    self ::
    self_value(): int {
        ret self;
    }
}

dyn_trait_dispatch(): int {
    dyn: *Dyn = box 4;
    ret dyn.value();
}

Size: trait {
    size(): Self;
}

size[T](): T
where T: Size {
    ret T::size();
}

impl Size for int {
    size(): Self {
        ret 8;
    }
}

impl Size for i8 {
    size(): Self {
        ret 1i8;
    }
}

static_trait_dispatch(): int {
    ret size[int]() + cast[int](size[i8]());
}

pub ::
Animal: trait {
    new(): Self;

    self ::
    trait_method[T, U](): Wrapper[T];
}

pub ::
AnimalTemplate[T]: trait {
    method[U](): T;
}

pub ::
Cow: struct {
    value: int
}

impl Animal for Cow {
    new(): Self {
        ret new Self { value: 2 };
    }

    self ::
    trait_method[T, U](): Wrapper[T] {
        ret new Wrapper[T] { value: self.value };
    }
}

traits(): int {
    i: int = 0;

    cow: Cow = Cow::new();
    i += cow.trait_method[int, int]().value;
    assert i == 2;

    animal:      *Animal = box new Cow { value: 5 };
    weak_animal: ~Animal = animal;

    ret i;
}

impl[T] Template[T] {
    new(field: int): Self {
        ret new Self { field };
    }
}

impl Node {
    new(value: int): Self {
        ret new Self { value };
    }
}

self_type(): int {
    ret Node::new(5).value - Template[int]::new(3).field;
}

pub ::
Node: struct {
    value: int
}

impl Node {
    self ::
    value(): int {
        ret self.value;
    }

    *self ::
    area(): int {
        ret self.value * self.value;
    }
}

boxed_self(): int {
    i: int = 0;

    node: Node = new Node { value: 3 };
    i += node.value();
    assert i == 3;

    boxed_node: *Node = box node;
    i += boxed_node.area();
    assert i == 12;

    ret i;
}

boxed_struct_compound_assignment(): int {
    value: Vector2 = new Vector2 { x: 0, y: 2 };

    boxed_value: *Vector2 = box value;
    boxed_value.y *= 2;

    ret boxed_value.y;
}

struct_compound_assignment(): int {
    value: Vector2 = new Vector2 { x: 0, y: 27 };
    value.y -= 1;
    ret value.y;
}

compound_assignment(): int {
    i: int = 10;
    increment_int(i);
    ret i;
}

pub ::
Vector2: pub struct {
    x: int, 
    y: int,
}

Template[T]: struct {
    field: T
}

impl Vector2 {
    pub self ::
    increment_all(): void {
        self.x += 1;
        self.y += 1;
    }

    pub ::
    increment_all_static(value: &Self): void {
        value.increment_all();
    }
}

test_1(): int {
    vec: Vector2 = new Vector2 { x: 15, y: 15 };
    vec.increment_all();

    vec_ref: &Vector2 = vec;
    vec_ref.increment_all();

    vec.increment_all();

    Vector2::increment_all_static(vec_ref);

    ret vec.y;
}

test_2: mod {
    pub ::
    Type: struct {
        field: int
    }

    impl Type {
        pub ::
        new(field: int): Self {
            ret new Self { field };
        }

        pub self ::
        field(): int { 
            ret self.field;
        }
    }

    private: mod {
        func(): int {
            obj: test_2::Type = new test_2::Type { field: 1 };
            ret obj.field;
        }
    }
}

test_3: mod {
    pub ::
    func(): int {
        ret -5;
    }
}

pub ::
test_3::nested: mod {
}

pub ::
test_3::nested: mod {
    pub ::
    func(): int {
        ret -10;
    }
}

test_4(): int {
    i: int = 0; 

    while i < 10 {
        print_int(i);
        i += 1;
    }

    ret i;
}

fizz_buzz(n: int): int {
    i: int = 1;
    while i <= n {
        is_divisable_by_three: bool = i % 3 == 0;
        is_divisable_by_five:  bool = i % 5 == 0;

        if is_divisable_by_three {
            if is_divisable_by_five {
                print_int(88881111);
            } else {
                print_int(8888);
            }
        } else {
            if is_divisable_by_five {
                print_int(1111);
            } else {
                print_int(i);
            }
        }

        i += 1;
    }

    ret 0;
}

control_flow_analysis_1(): int {
    if false {
        ret 15;
    } else {
        ret 16;
    }
}

control_flow_analysis_2(): int {
    while true {
        ret 12;
    }

    ret 16;
}

impl[T] Template[T] {
    pub self ::
    field(): T {
        ret self.field;
    }
}

type_template_associated_func(): int {
    obj: Template[int] = new Template[int] { field: 4 };
    ret obj.field();
}

impl[T] Template[T] {
    func_normal(): void {
        print_int(15);
    }

    func_template[U](): void {
        print_int(25);
    }
}

type_template_associated_func_template(): int {
    Template[int]::func_normal();
    Template[int]::func_template[std::Ptr]();
    ret 10;
}

free_func_template[T](value: T): T {
    ret value;
}

free_func_template_test(): int {
    ret free_func_template[int](-13);
}

impl[T] Template[T] {
    self ::
    get_field_template[U](): T {
        ret self.field;
    }
}

method_template(): int {
    obj: Template[int] = new Template[int] { field: -12 };
    obj.get_field_template[std::Ptr]();
    ret 13;
}

clamp(d: int, min: int, max: int): int {
    t: int;

    if d < min { t = min; }
    else       { t = d; }

    if t > max { ret max; }
    else       { ret t; }
}

impl Vector2 {
    self ::
    associated_func_template[T](): void { 
    }
}

type_associated_template_func(): int {
    vec: Vector2 = new Vector2 { x: 0, y: 0 };
    vec.associated_func_template[int]();
    ret vec.x + vec.y;
}

impl Vector2 {
    self ::
    increment_x_and_y(): void {
        self.x += 1;
        self.y += 1;
    }
}

reference(): int {
    vec_a: Vector2 = new Vector2 { x: 48, y: 11 };
    vec_b: Vector2 = new Vector2 { x: -9, y: 59 };

    vec_b.increment_x_and_y();

    vec_ref: &Vector2 = vec_b;

    vec_b.x += 1;

    vec_final: Vector2 = vec_ref;

    ret vec_final.x;
}

argument(value: int): int {
    ret value;
}

address(): int {
    value: int = 0;
    address_of_value: std::Ptr = __address_of(value);
    ret value;
}

size_of_vector_2(): int {
    ret __size_of[Vector2];
}

memory_allocation(): int {
    size_of_int: int = __size_of[int];
    block: std::Ptr = std::mem::alloc(size_of_int);
    std::mem::dealloc(block);
    ret 0;
}

memory_allocation_copy_access(): int {
    vector_2_size: int = __size_of[Vector2];
    vector_2_ptr: std::Ptr = std::mem::alloc(vector_2_size);

    init_value: Vector2 = new Vector2 { x: 15, y: 7 };
    init_value_ptr: std::Ptr = __address_of(init_value);

    std::mem::copy(init_value_ptr, vector_2_ptr, vector_2_size);

    __deref_as[Vector2](vector_2_ptr).y = 46;

    vector_2_deref_y: int = __deref_as[Vector2](vector_2_ptr).y;

    std::mem::dealloc(vector_2_ptr);

    ret vector_2_deref_y;
}

print_vector_2_strong_ptr_x(value: &*Vector2): void {
    print_int(value.x);
}

print_vector_2_strong_ptr_y(value: &*Vector2): void {
    print_int(value.y);
}

reference_counting(): int {
    strong: *Vector2 = box new Vector2 { x: 16, y: 10 };
    print_vector_2_strong_ptr_y(strong);

    weak: ~Vector2 = strong;

    locked: *Vector2 = lock weak;
    print_vector_2_strong_ptr_x(locked);

    unboxed_value: Vector2 = unbox locked;
    print_int(unboxed_value.y);

    ret 0;
}

multiple_indirection(): int {
    vec_1: *Vector2 = box new Vector2 { x: -7, y: 4 };
    vec_2: **Vector2 = box vec_1;
    vec_3: &**Vector2 = vec_2;

    ret vec_3.x;
}

increment_int(value: &int): void {
    value += 1;
}

op_precedence(): int {
    i: int = -int_value();
    print_int(i);
    ret 0;
}

int_value(): int {
    ret -131255;
}

op_associativity(): int {
    ret 1 * -100 + 50 / 10 / 5;
}

Getter: struct {
    field: int,
}

impl Getter {
    self ::
    field(): int {
        ret self.field;
    }
}

getter(): int {
    print_int(15);
    obj: Getter = new Getter { field: int_value_and_print() };
    print_int(60);
    ret obj.field();
}

int_value_and_print(): int {
    value: int = -123152;
    print_int(value);
    ret value;
}

global_value: int;
global(): int {
    global_value = -9843;
    ret global_value;
}

NewTemplate[T]: struct {}

deducable[T, U](lhs: T, rhs: U): T {
    new NewTemplate[U] {};
    ret lhs;
}

deducer(): int {
    ret deducable(2, 5i8);
}

Wrapper[T]: struct {
    value: T
}

unwrap[T](wrapped: Wrapper[T]): T {
    ret wrapped.value;
}

unwrapper(): int {
    wrapped: Wrapper[int] = new Wrapper[int] { value: -1001001 };
    ret unwrap(wrapped);
}

implicit_conversion_with_binary_op(): int {
    i: i32 = 5i32 + 9i16;
    ret 0;
}
